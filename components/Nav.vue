<template>
  <div id="nav3d" class="nav3d">
    <div
      id="navContainer"
      ref="navContainer"
      v-scroll-lock="isOpen"
      :class="{ navContainer: true, navContainerMobile: isMobile }"
    >
      <div
        id="sceneContainer"
        ref="sceneContainer"
        :class="{ sceneContainer: true, sceneContainerMobile: isMobile }"
      >
        <canvas id="scene" ref="scene" class="scene" />
      </div>
    </div>
    <div
      id="toggleContainer"
      :class="{ toggleContainer: true, toggleContainerMobile: isMobile }"
    >
      <NavToggle />
    </div>
    <div
      id="navFeedContainer"
      :class="{ navFeedContainer: true, navFeedContainerMobile: isMobile }"
    >
      <NavFeed @clicked="handleNav()">Planet Huh</NavFeed>
    </div>
  </div>
</template>

<script>
import * as THREE from "three"
import gsap from "gsap"
import globeTexture from "@/assets/images/globe.png"
import NavToggle from "@/components/NavToggle"
import NavFeed from "@/components/NavFeed"

export default {
  components: {
    NavToggle,
    NavFeed,
  },
  data() {
    return {
      toggle: false,
      currentNav: null,
      observer: null,
      intersected: false,
      initialPlay: true,
    }
  },

  computed: {
    isIndex() {
      return this.$route.fullPath === "/"
    },
    isMobile() {
      return this.$device.isMobileOrTablet
    },
    isNavLarge() {
      return this.$store.state.transitions.isNavLarge
    },
    isOpen() {
      return this.$store.state.transitions.isOpen
    },
    cities() {
      return this.$store.state.nav.cities
    },
    colors() {
      return Object.values(this.$store.state.nav.moods)
    },
  },
  mounted() {
    this.observer = new IntersectionObserver((entries) => {
      const nav = entries[0]
      if (nav.isIntersecting) {
        this.$store.state.transitions.play()
      } else {
        !this.isIndex
          ? this.$store.state.transitions.pause(400)
          : this.$store.state.transitions.pause(0)
      }
    })

    this.observer.observe(this.$refs.navContainer)

    if (!this.isIndex) {
      this.$store.dispatch("transitions/setNavStyle", this.isMobile)
    }

    // add listener functions to vuex
    this.$store.commit(
      "transitions/setAddHandleNavListeners",
      this.addHandleNavListeners
    )
    this.$store.commit(
      "transitions/setRemoveHandleNavListeners",
      this.removeHandleNavListeners
    )

    this.initThree()
  },
  beforeDestroy() {
    this.onDestroy()
    this.observer.disconnect()
  },
  methods: {
    addHandleNavListeners() {
      const nav = document.querySelector("#navContainer")
      nav.addEventListener("click", this.handleNav, false)
      nav.addEventListener("touchstart", this.handleNav, false)
    },
    removeHandleNavListeners() {
      const nav = document.querySelector("#navContainer")
      nav.removeEventListener("click", this.handleNav, false)
      nav.removeEventListener("touchstart", this.handleNav, false)
    },
    onDestroy() {
      if (!this.isNavLarge) {
        const nav = document.querySelector("#navContainer")
        nav.removeEventListener("click", this.route, false)
        nav.removeEventListener("touchstart", this.route, false)
      }
    },
    setNavSmall() {
      this.$store.state.transitions.clearTarget()
      this.$store.dispatch("transitions/setNavSmall")
      this.$store.dispatch("transitions/setNavContainerSmall")
    },
    setNavLarge() {
      if (this.isIndex) {
        this.$store.dispatch("transitions/setNavLarge")
        this.$store.dispatch("transitions/setNavContainerLarge")
      } else {
        this.$store.state.transitions.removeHandleNavListeners()
      }
    },
    handleNav() {
      if (!gsap.isTweening("#navContainer")) {
        this.isNavLarge ? this.setNavSmall() : this.setNavLarge()
      }
    },
    initThree() {
      // Render Controls

      const pauseAnimation = (timeout) => {
        setTimeout(() => {
          this.$store.commit("transitions/setIsPlay", false)
        }, timeout)
      }

      const playAnimation = () => {
        this.$store.commit("transitions/setIsPlay", true)
        requestAnimationFrame(render)
      }

      this.$store.commit("transitions/setPause", pauseAnimation)
      this.$store.commit("transitions/setPlay", playAnimation)

      const sceneContainer = document.querySelector("#navContainer")

      let isDragging = false
      let isThrowing = false

      const MAX_ANGLES = {
        x: {
          // Vertical from bottom to top.
          enabled: true,
          from: Math.PI / 4,
          to: Math.PI / 4,
        },
        y: {
          // Horizontal from left to right.
          enabled: false,
          from: Math.PI / 4,
          to: Math.PI / 4,
        },
      }

      const rotationSpeed = this.isMobile ? 0.0055 : 0.0035
      const rotationInertia = this.isMobile ? 0.09 : 0.08

      // horizonal rotation

      let targetRotationXGlobe = 0
      let targetRotationXMood = 0
      let targetRotationOnMouseDownX = 0

      let mouseX = 0
      let mouseXOnMouseDown = 0

      let windowHalfX = window.innerWidth / 2

      let deltaX = 0

      // vertical rotation

      let targetRotationYGlobe = 0
      let targetRotationYMood = 0
      let targetRotationOnMouseDownY = 0

      let mouseY = 0
      let mouseYOnMouseDown = 0

      let windowHalfY = window.innerWidth / 2

      let deltaY = 0

      const checkMaxAngle = (obj, delta, axe) => {
        const condition =
          MAX_ANGLES[axe].from * -1 < obj.rotation[axe] + delta &&
          obj.rotation[axe] + delta < MAX_ANGLES[axe].to

        return condition
      }

      // camera zoom

      const maxZoom = this.isMobile ? -1.8 : -0.5
      const minZoom = 0
      const zoomInSpeed = 1.05
      let zoomPosition = 0.005
      const zoomOutSpeed = 0.0015

      // RAYCASTER

      const raycaster = new THREE.Raycaster()
      const rayMouse = new THREE.Vector2()
      let currentTarget = null
      let intersects = null

      const raycasterTitle = new THREE.Raycaster()
      let intersectsTitle = null

      const setTarget = (target) => {
        target ? (currentTarget = target) : (currentTarget = null)

        if (currentTarget && this.isMobile) {
          sceneContainer.addEventListener("touchstart", navRouterMobile, false)
        }

        if (!currentTarget && this.isMobile) {
          sceneContainer.removeEventListener(
            "touchstart",
            navRouterMobile,
            false
          )
        }
      }

      const clearTarget = () => {
        rayMouse.x = null
        rayMouse.y = null
        intersects = null
        currentTarget = null
        setTarget(null)
        removeTitle()
        removeSprites()
      }

      this.$store.commit("transitions/setClearTarget", clearTarget)

      const navRouterMobile = (e) => {
        // Update Raycaster
        const rect = renderer.domElement.getBoundingClientRect()
        rayMouse.x = ((e.touches[0].clientX - rect.left) / rect.width) * 2 - 1
        rayMouse.y =
          -((e.touches[0].clientY - rect.top) / (rect.bottom - rect.top)) * 2 +
          1

        raycaster.setFromCamera(rayMouse, camera)

        intersects = raycaster.intersectObjects(
          this.currentNav === pivotGlobe ? spriteCities : spriteMoodsFlat
        )

        if (
          intersects[0].object === currentTarget &&
          !currentTarget.name.includes("coming soon")
        ) {
          this.$router.push({
            name: "categories",
            query: { filters: currentTarget.name },
          })

          clearTarget()
        }
      }

      const navRouter = () => {
        if (currentTarget && !currentTarget.name.includes("coming soon")) {
          this.$router.push({
            name: "categories",
            query: { filters: currentTarget.name },
          })
        }
      }

      if (!this.isMobile) {
        sceneContainer.addEventListener("click", navRouter, false)
      }

      // LERP TIMER

      let lerpTimerBool = true
      const lerpTimerFn = () => {
        lerpTimerBool = true
      }
      let lerpTimer

      const setLerpTimer = () => {
        clearInterval(lerpTimer)
        lerpTimer = setInterval(lerpTimerFn, this.isMobile ? 1500 : 6000)
      }

      const clearLerpTimer = () => {
        clearInterval(lerpTimer)
        lerpTimerBool = true
      }

      // OBJECT CONTROLS

      // MOUSE DESKTOP

      const mouseDown = (e) => {
        if (e.button === 0) {
          isDragging = true
          isThrowing = true
          lerpTimerBool = false

          setLerpTimer()

          mouseXOnMouseDown = e.clientX - windowHalfX
          mouseYOnMouseDown = e.clientY - windowHalfY

          if (this.currentNav === pivotGlobe) {
            targetRotationOnMouseDownX = targetRotationXGlobe
            targetRotationOnMouseDownY = targetRotationYGlobe
          }

          if (this.currentNav === pivotMood) {
            targetRotationOnMouseDownX = targetRotationXMood
            targetRotationOnMouseDownY = -targetRotationYMood
          }
        }
      }

      const mouseMove = (e) => {
        // Raycaster
        const rect = renderer.domElement.getBoundingClientRect()
        rayMouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1
        rayMouse.y =
          -((event.clientY - rect.top) / (rect.bottom - rect.top)) * 2 + 1

        raycaster.setFromCamera(rayMouse, camera)

        if (this.currentNav === pivotGlobe) {
          intersects = raycaster.intersectObjects(spriteCities)

          if (intersects.length > 0 && intersects[0].object.name === "mood") {
            toggleHover = true
          } else {
            toggleClick = false
            toggleHover = false
          }
        }

        if (this.currentNav === pivotMood) {
          intersects = raycaster.intersectObjects(spriteMoodsFlat)

          if (intersects.length > 0 && intersects[0].object.name === "globe") {
            toggleHover = true
          } else {
            toggleClick = false
            toggleHover = false
          }
        }

        if (
          intersects.length >= 2 &&
          intersects[0].object.name !== "globe" &&
          intersects[0].object.name !== "mood" &&
          currentTarget !== intersects[0].object &&
          !gsap.isTweening(pivotMain.rotation)
        ) {
          setTarget(intersects[0].object)
          addTitle(intersects[0].object)
          addSprites(intersects[0].object)
        }

        if (intersects.length < 2 && currentTarget) {
          setTarget(null)
          removeTitle()
          removeSprites()
        }

        if (isDragging) {
          mouseX = e.clientX - windowHalfX
          mouseY = e.clientY - windowHalfY

          const delta =
            targetRotationOnMouseDownY +
            (mouseY - mouseYOnMouseDown) * rotationSpeed

          if (this.currentNav === pivotGlobe) {
            targetRotationXGlobe =
              targetRotationOnMouseDownX +
              (mouseX - mouseXOnMouseDown) * rotationSpeed

            if (delta <= MAX_ANGLES.x.from * -1) {
              targetRotationYGlobe = MAX_ANGLES.x.from * -1
            } else if (delta >= MAX_ANGLES.x.from) {
              targetRotationYGlobe = MAX_ANGLES.x.from
            } else {
              targetRotationYGlobe =
                targetRotationOnMouseDownY +
                (mouseY - mouseYOnMouseDown) * rotationSpeed
            }
          }

          if (this.currentNav === pivotMood) {
            targetRotationXMood =
              targetRotationOnMouseDownX +
              (mouseX - mouseXOnMouseDown) * rotationSpeed

            if (delta <= MAX_ANGLES.x.from * -1) {
              targetRotationYMood = MAX_ANGLES.x.from
            } else if (delta >= MAX_ANGLES.x.from) {
              targetRotationYMood = MAX_ANGLES.x.from * -1
            } else {
              targetRotationYMood =
                (targetRotationOnMouseDownY +
                  (mouseY - mouseYOnMouseDown) * rotationSpeed) *
                -1
            }
          }
        }
      }

      const mouseUp = (e) => {
        isDragging = false
        zoomPosition = 0.005
      }

      // TOUCH CONTROLS

      // mouse down
      const onTouchStart = (e) => {
        e.preventDefault()
        setLerpTimer()

        // Mobile Raycaster
        const rect = renderer.domElement.getBoundingClientRect()
        rayMouse.x = ((e.touches[0].clientX - rect.left) / rect.width) * 2 - 1
        rayMouse.y =
          -((e.touches[0].clientY - rect.top) / (rect.bottom - rect.top)) * 2 +
          1

        raycaster.setFromCamera(rayMouse, camera)

        if (this.currentNav === pivotGlobe) {
          intersects = raycaster.intersectObjects(spriteCities)

          if (intersects.length > 0 && intersects[0].object.name === "mood") {
            toggleHover = true
          } else {
            toggleClick = false
            toggleHover = false
          }
        }

        if (this.currentNav === pivotMood) {
          intersects = raycaster.intersectObjects(spriteMoodsFlat)

          if (intersects.length > 0 && intersects[0].object.name === "globe") {
            toggleHover = true
          } else {
            toggleClick = false
            toggleHover = false
          }
        }

        if (
          intersects.length >= 2 &&
          intersects[0].object.name !== "globe" &&
          intersects[0].object.name !== "mood" &&
          currentTarget !== intersects[0].object
        ) {
          if (currentTarget) {
            setTarget(null)
            removeTitle()
            removeSprites()
          }
          setTarget(intersects[0].object)
          addTitle(intersects[0].object)
          addSprites(intersects[0].object)
        }

        isDragging = true
        isThrowing = true
        lerpTimerBool = false

        mouseXOnMouseDown = e.touches[0].clientX - windowHalfX
        mouseYOnMouseDown = e.touches[0].clientY - windowHalfY

        if (this.currentNav === pivotGlobe) {
          targetRotationOnMouseDownX = targetRotationXGlobe
          targetRotationOnMouseDownY = targetRotationYGlobe
        }

        if (this.currentNav === pivotMood) {
          targetRotationOnMouseDownX = targetRotationXMood
          targetRotationOnMouseDownY = -targetRotationYMood
        }
      }

      // on mouse move
      const onTouchMove = (e) => {
        e.preventDefault()

        if (isDragging) {
          mouseX = e.touches[0].clientX - windowHalfX
          mouseY = e.touches[0].clientY - windowHalfY

          const delta =
            targetRotationOnMouseDownY +
            (mouseY - mouseYOnMouseDown) * rotationSpeed

          if (this.currentNav === pivotGlobe) {
            targetRotationXGlobe =
              targetRotationOnMouseDownX +
              (mouseX - mouseXOnMouseDown) * rotationSpeed

            if (delta <= MAX_ANGLES.x.from * -1) {
              targetRotationYGlobe = MAX_ANGLES.x.from * -1
            } else if (delta >= MAX_ANGLES.x.from) {
              targetRotationYGlobe = MAX_ANGLES.x.from
            } else {
              targetRotationYGlobe =
                targetRotationOnMouseDownY +
                (mouseY - mouseYOnMouseDown) * rotationSpeed
            }
          }

          if (this.currentNav === pivotMood) {
            targetRotationXMood =
              targetRotationOnMouseDownX +
              (mouseX - mouseXOnMouseDown) * rotationSpeed

            if (delta <= MAX_ANGLES.x.from * -1) {
              targetRotationYMood = MAX_ANGLES.x.from
            } else if (delta >= MAX_ANGLES.x.from) {
              targetRotationYMood = MAX_ANGLES.x.from * -1
            } else {
              targetRotationYMood =
                (targetRotationOnMouseDownY +
                  (mouseY - mouseYOnMouseDown) * rotationSpeed) *
                -1
            }
          }
        }
      }

      const resetRayMouse = () => {
        rayMouse.x = null
        rayMouse.y = null
        raycaster.setFromCamera(rayMouse, camera)

        intersects = raycaster.intersectObjects(
          this.currentNav === pivotGlobe ? spriteCities : spriteMoodsFlat
        )
      }

      // mouse up
      const onTouchEnd = (e) => {
        isDragging = false
        zoomPosition = 0.005
        // resetRayMouse()
      }

      // mouse event listeners
      if (!this.isMobile) {
        const addHandlers = () => {
          sceneContainer.addEventListener("mousedown", mouseDown, {
            passive: true,
          })
          sceneContainer.addEventListener("mousemove", mouseMove, {
            passive: true,
          })
          sceneContainer.addEventListener("mouseup", mouseUp, {
            passive: true,
          })
        }

        const removeHandlers = () => {
          isDragging = false
          zoomPosition = 0.005

          sceneContainer.removeEventListener("mousedown", mouseDown)
          sceneContainer.removeEventListener("mousemove", mouseMove)
          sceneContainer.removeEventListener("mouseup", mouseUp)
        }

        addHandlers()

        sceneContainer.addEventListener("mouseover", addHandlers, {
          passive: true,
        })
        sceneContainer.addEventListener("mouseout", removeHandlers, {
          passive: true,
        })
      }

      // touch event listeners

      sceneContainer.addEventListener("touchstart", onTouchStart, false)
      sceneContainer.addEventListener("touchmove", onTouchMove, false)
      sceneContainer.addEventListener("touchend", onTouchEnd, false)

      // INITIALIZE CANVAS

      const canvas = this.$refs.scene
      const renderer = new THREE.WebGLRenderer({
        canvas,
        antialias: true,
        alpha: true,
        // powerPreference: "high-performance",
      })
      renderer.setPixelRatio(window.devicePixelRatio)
      renderer.setClearColor(0x000000, 0)
      const scene = new THREE.Scene()

      // CAMERA PIVOT

      const pivotCamera = new THREE.Object3D()
      pivotCamera.position.set(0, 0, this.isMobile ? 6.5 : 4.75)
      scene.add(pivotCamera)

      // CAMERA

      const camera = new THREE.PerspectiveCamera(45, 2, 1, 12)
      pivotCamera.add(camera)
      camera.lookAt(0, 0, this.isMobile ? -6.5 : -4.75)

      // LIGHTING

      {
        const color = 0xffffff
        const intensity = 0.95
        const light = new THREE.AmbientLight(color, intensity)
        scene.add(light)
      }

      // MAIN PIVOT

      const pivotMain = new THREE.Object3D()
      pivotMain.position.set(1.2, 0, -2)
      scene.add(pivotMain)

      // GLOBE PIVOT

      const pivotGlobe = new THREE.Object3D()
      pivotGlobe.position.set(-1.2, 0, 2)
      pivotMain.add(pivotGlobe)
      this.currentNav = pivotGlobe

      // GLOBE OBJECT

      let globe
      const loader = new THREE.TextureLoader()
      const geometry = new THREE.SphereBufferGeometry(1, 64, 64)
      let textureLoaded = false

      {
        const texture = loader.load(globeTexture, (texture) => {
          textureLoaded = true
          this.$nextTick(() => this.$store.state.finish())
        })
        texture.anisotropy = renderer.capabilities.getMaxAnisotropy()
        const material = new THREE.MeshPhongMaterial({
          map: texture,
        })
        material.map.minFilter = THREE.LinearFilter
        globe = new THREE.Mesh(geometry, material)
        globe.name = "globe"
        pivotGlobe.add(globe)
      }

      // MOOD PIVOT

      const pivotMood = new THREE.Object3D()
      pivotMood.position.set(1.2, 0, -2)
      pivotMain.add(pivotMood)

      // MOOD OBJECT

      // functions

      const calcWeight = (moodsArr, index) => {
        function getSum(total, num) {
          return total + Math.round(num)
        }

        const multiplier = 0.4

        const moodsAvg =
          moodsArr.map((mood) => mood.posts.length).reduce(getSum, 0) /
          moodsArr.length

        return moodsArr[index].posts.length - moodsAvg === 0
          ? 1
          : 1 +
              ((moodsArr[index].posts.length - moodsAvg) / moodsAvg) *
                multiplier
      }

      this.colors.forEach((color, index) => {
        // calculate weight
        const weight = calcWeight(this.colors, index)

        // calculate position
        const [x, y, z] = calcPosition(color.latitude, color.longitude, 1)

        this.colors[index] = { ...this.colors[index], weight, x, y, z }

        // add positions
        this.colors[index].positions = []
      })

      const getDistance = (x1, y1, z1, x2, y2, z2) => {
        const dx = x1 - x2
        const dy = y1 - y2
        const dz = z1 - z2
        return Math.sqrt(dx * dx + dy * dy + dz * dz)
      }

      const calculateColor = (colors, x, y, z) => {
        let total = 0
        const distances = []

        // for all colors
        for (let i = 0; i < colors.length; i += 1) {
          const c = colors[i]
          let d = getDistance(c.x, c.y, c.z, x, y, z) / colors[i].weight
          distances.push(d)

          d = 1 / d ** 3
          c.d = d
          c.d = d
          total += d
        }

        // find minumum value
        const minDistance = Math.min.apply(null, distances)

        // add position to colors
        if (y >= -0.7 && y <= 0.7 && minDistance < 0.5) {
          colors[distances.indexOf(minDistance)].positions.push([x, y, z])
        }

        // push coordinates into mood locations object
        let r = 0
        let g = 0
        let b = 0

        for (let i = 0; i < colors.length; i += 1) {
          const c = colors[i]
          const ratio = c.d / total

          r += ratio * c.r
          g += ratio * c.g
          b += ratio * c.b
        }

        r = Math.floor(r)
        g = Math.floor(g)
        b = Math.floor(b)
        return { r, g, b }
      }

      let mood

      {
        const vertexShader = `
          precision mediump float;
          precision mediump int;

          attribute vec4 color;
          varying vec4 vColor;

          void main()    {

            vColor = color;

            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

          }
        `

        const fragmentShader = `
          precision mediump float;
          precision mediump int;

          varying vec4 vColor;

          void main()    {

            vec4 color = vec4( vColor );
            gl_FragColor = color;

          }
        `

        const material = new THREE.ShaderMaterial({
          uniforms: {
            viewVector: {
              type: "v3",
              value: camera.position,
            },
          },
          vertexShader,
          fragmentShader,
          transparent: true,
        })

        const { count } = geometry.attributes.position
        geometry.setAttribute(
          "color",
          new THREE.BufferAttribute(new Float32Array(count * 4), 4)
        )

        const positions = geometry.attributes.position
        const positionColor = geometry.attributes.color

        for (let i = 0; i < count; i += 1) {
          const calculatedColor = calculateColor(
            this.colors,
            positions.getX(i),
            positions.getY(i),
            positions.getZ(i)
          )

          positionColor.setXYZW(
            i,
            calculatedColor.r / 255,
            calculatedColor.g / 255,
            calculatedColor.b / 255,
            0.8
          )
        }

        mood = new THREE.Mesh(geometry, material)
        mood.name = "mood"
        pivotMood.add(mood)
      }

      // RESIZE

      const resizeRendererToDisplaySize = (renderer) => {
        windowHalfX = window.innerWidth / 2
        windowHalfY = window.innerHeight / 2

        const width = canvas.clientWidth
        const height = canvas.clientHeight
        const needResize = canvas.width !== width || canvas.height !== height
        if (needResize) {
          renderer.setSize(width, height, false)
        }
        return needResize
      }

      // SLERP PIVOT GLOBE

      const toRadians = (angle) => {
        return angle * (Math.PI / 180)
      }

      const globeRadians = toRadians(0)

      const globeAxis = new THREE.Vector3(
        Math.sin(globeRadians),
        Math.cos(globeRadians),
        0
      ).normalize()

      // TOGGLE OBJECTS

      let toggleClick = false
      let toggleHover = false
      let rotatePosition = 0

      {
        const toggleAnim = () => {
          clearLerpTimer()
          resetRayMouse()

          if (!gsap.isTweening(pivotMain.rotation)) {
            if (this.currentNav === pivotGlobe) {
              gsap.to("#ball", 0.4, {
                x: "23px",
                backgroundColor: "#FB95B8",
              })
            }

            if (this.currentNav === pivotMood) {
              gsap.to("#ball", 0.4, {
                x: "0px",
                backgroundColor: "#749bff",
              })
            }

            rotatePosition += Math.PI
            gsap.to(pivotMain.rotation, 1, { y: rotatePosition })

            this.currentNav === pivotGlobe
              ? (this.currentNav = pivotMood)
              : (this.currentNav = pivotGlobe)
          }
        }

        document.querySelector("#toggle").addEventListener("click", toggleAnim)

        const checkToggleClick = () => {
          if (toggleHover) {
            toggleClick = true
          }
        }

        const checkToggleHover = () => {
          if (toggleHover && toggleClick) {
            toggleAnim()
          }
        }

        const addNavClick = () => {
          sceneContainer.addEventListener("mousedown", checkToggleClick)
          sceneContainer.addEventListener("click", checkToggleHover)
        }

        const removeNavClick = () => {
          sceneContainer.removeEventListener("mousedown", checkToggleClick)
          sceneContainer.removeEventListener("click", checkToggleHover)
        }

        if (this.isIndex) {
          addNavClick()
        }

        this.$store.commit("transitions/setAddNavClick", addNavClick)
        this.$store.commit("transitions/setRemoveNavClick", removeNavClick)
      }

      // SET ROTATION AXIS

      globe.geometry.applyMatrix4(
        new THREE.Matrix4().makeRotationZ(-globeRadians)
      )

      // CITIES

      const citiesArr = []

      const spriteMapBlue = new THREE.TextureLoader().load(
        "/sprites/mapDot.png"
      )
      const spriteMapWhite = new THREE.TextureLoader().load(
        "/sprites/mapDot2.png"
      )
      const spriteMapBlack = new THREE.TextureLoader().load(
        "/sprites/mapDot3.png"
      )

      const spriteCities = []
      const spriteCitiesMats = []

      const spriteCitiesAlt = []
      const spriteCitiesMatsAlt = []

      function calcPosition(lat, lon, radius) {
        const phi = (90 - lat) * (Math.PI / 180)
        const theta = (lon + 180.7) * (Math.PI / 180)

        const x = -(radius * Math.sin(phi) * Math.cos(theta))
        const z = radius * Math.sin(phi) * Math.sin(theta)
        const y = radius * Math.cos(phi)

        return [x, y, z]
      }

      const addCities = () => {
        this.cities.forEach((city, index) => {
          // City Location
          const position = calcPosition(city[0], city[1], 1.015)

          // Main Object
          citiesArr.push(new THREE.Object3D())
          citiesArr[index].position.set(position[0], position[1], position[2])
          globe.add(citiesArr[index])

          // Main Material for each Sprite
          spriteCitiesMats.push(
            new THREE.SpriteMaterial({ map: spriteMapBlue })
          )
          spriteCitiesMats[index].name = "Main"
          spriteCitiesMats[index].transparent = true

          // Main Sprite for each City
          spriteCities.push(new THREE.Sprite(spriteCitiesMats[index]))
          spriteCities[index].name = city[2]
          spriteCities[index].scale.set(0.07, 0.07, 1)
          citiesArr[index].add(spriteCities[index])

          // Alt Material for each Sprite
          spriteCitiesMatsAlt.push(
            new THREE.SpriteMaterial({ map: spriteMapWhite })
          )
          spriteCitiesMatsAlt[index].name = "Alt"
          spriteCitiesMatsAlt[index].transparent = true

          // Alt Sprite for each City
          spriteCitiesAlt.push(new THREE.Sprite(spriteCitiesMatsAlt[index]))
          spriteCitiesAlt[index].name = city[2]
          spriteCitiesAlt[index].scale.set(0.07, 0.07, 1)
          spriteCitiesAlt[index].material.opacity = 0
          citiesArr[index].add(spriteCitiesAlt[index])
        })

        spriteCities.push(globe)
        spriteCities.push(mood)
      }

      addCities()

      // MOODS

      const moodsArr = {}
      const spriteMoods = {}
      const spriteMoodsMats = {}
      const spriteMoodsAlt = {}
      const spriteMoodsMatsAlt = {}
      const spriteTextArrMoods = {}

      this.colors.forEach((color) => {
        moodsArr[color.name] = []
        spriteMoods[color.name] = []
        spriteMoodsMats[color.name] = []
        spriteMoodsAlt[color.name] = []
        spriteMoodsMatsAlt[color.name] = []
        spriteTextArrMoods[color.name] = []
      })

      const getMoodPosition = (moodsArr, positions) => {
        let position
        let distance
        let distanceBool = false
        const minDistance = 0.3
        position = positions[Math.floor(Math.random() * positions.length)]

        if (moodsArr.length > 0) {
          while (!distanceBool) {
            let counter = 0

            for (let i = 0; i < moodsArr.length; i += 1) {
              distance = getDistance(
                position[0],
                position[1],
                position[2],
                moodsArr[i].position.x,
                moodsArr[i].position.y,
                moodsArr[i].position.z
              )

              if (distance < minDistance) {
                break
              }

              counter += 1
            }

            if (counter >= moodsArr.length) {
              distanceBool = true
            }

            if (!distanceBool) {
              counter = 0
              position = positions[Math.floor(Math.random() * positions.length)]
            }
          }
        }

        return position
      }

      const addMoods = () => {
        this.colors.forEach((color) => {
          color.posts.forEach((post, index) => {
            // Get Position
            const position = getMoodPosition(
              moodsArr[color.name],
              color.positions
            )

            // Main Object
            moodsArr[color.name].push(new THREE.Object3D())
            moodsArr[color.name][index].position.set(
              position[0] * 1.022,
              position[1] * 1.022,
              position[2] * 1.022
            )
            mood.add(moodsArr[color.name][index])

            // Main Material for each Sprite
            spriteMoodsMats[color.name].push(
              new THREE.SpriteMaterial({ map: spriteMapWhite })
            )
            spriteMoodsMats[color.name][index].name = "Main"
            spriteMoodsMats[color.name][index].transparent = true

            // Main Sprite for each City
            spriteMoods[color.name].push(
              new THREE.Sprite(spriteMoodsMats[color.name][index])
            )
            spriteMoods[color.name][index].name = post.title
            spriteMoods[color.name][index].scale.set(0.09, 0.09, 1)
            moodsArr[color.name][index].add(spriteMoods[color.name][index])

            // Alt Material for each Sprite
            spriteMoodsMatsAlt[color.name].push(
              new THREE.SpriteMaterial({ map: spriteMapBlack })
            )
            spriteMoodsMatsAlt[color.name][index].name = "Alt"
            spriteMoodsMatsAlt[color.name][index].transparent = true

            // Alt Sprite for each City
            spriteMoodsAlt[color.name].push(
              new THREE.Sprite(spriteMoodsMatsAlt[color.name][index])
            )
            spriteMoodsAlt[color.name][index].name = post.title
            spriteMoodsAlt[color.name][index].scale.set(0.09, 0.09, 1)
            spriteMoodsAlt[color.name][index].material.opacity = 0
            moodsArr[color.name][index].add(spriteMoodsAlt[color.name][index])
          })
        })

        spriteMoods.mood = mood
        spriteMoods.globe = globe
      }

      addMoods()

      // RAYCASTER ARRAYS

      const spriteMoodsFlat = Object.values(spriteMoods).flat()
      const spritesAllAlt = spriteCitiesAlt.concat(
        Object.values(spriteMoodsAlt).flat()
      )

      // SPRITES
      const activeSprites = []

      const addSprites = (mainSprite) => {
        gsap.to(mainSprite.material, 0.4, { opacity: 0 })
        const altSprite = spritesAllAlt.filter(
          (sprite) => sprite.name === mainSprite.name
        )[0]
        gsap.to(altSprite.material, 0.4, { opacity: 1 })

        activeSprites.push([mainSprite.material, altSprite.material])

        // fade all others
        removeSprites(mainSprite.material, altSprite.material)
      }

      const removeSprites = (mainSprite = null, altSprite = null) => {
        activeSprites.forEach((arr) => {
          if (arr[0] !== mainSprite && arr[1] !== altSprite) {
            gsap.to(arr[0], 0.4, { opacity: 1 })
            gsap.to(arr[1], 0.4, { opacity: 0 })
          }
        })
      }

      // TITLE TEXT
      const activeTitles = []
      const posRaycast = new THREE.Vector2()

      const setActiveTitles = () => {
        for (let i = 0; i < activeTitles.length; i += 1) {
          let pos = new THREE.Vector3()
          pos = pos.setFromMatrixPosition(activeTitles[i][0].matrixWorld)
          pos.project(camera)

          posRaycast.x = pos.x
          posRaycast.y = pos.y

          const widthHalf = canvas.clientWidth / 2
          const heightHalf = canvas.clientHeight / 2

          pos.x = pos.x * widthHalf + widthHalf + 15
          pos.y = -(pos.y * heightHalf) + heightHalf - 7

          gsap.set(activeTitles[i][1], {
            x: pos.x,
            y: pos.y,
          })
        }
      }

      const navRouterTitle = (e) => {
        if (e.target && !e.target.title.includes("coming soon")) {
          this.$router.push({
            name: "categories",
            query: { filters: currentTarget.name },
          })

          clearTarget()
        }
      }

      const addTitle = (object) => {
        // add new title
        const title = document.createElement("a")
        title.classList.add("title")
        const text = document.createTextNode(`${object.name}`)
        title.append(text)
        title.style.position = "absolute"
        title.title = object.name

        title.addEventListener("click", navRouterTitle, {
          passive: true,
        })
        title.addEventListener("touchstart", navRouterTitle, {
          passive: true,
        })

        this.$refs.sceneContainer.append(title)

        const tl = gsap.timeline()
        tl.set(title, {
          fontSize: "0.8rem",
          fontWeight: 500,
          opacity: 0,
          left: 0,
          top: 0,
          margin: 0,
          transform: "translateY(-50%)",
          pointerEvents: "auto",
          textTransform: "capitalize",
        }).to(title, 0.3, { alpha: 1 })

        const newTitle = [object, title]

        activeTitles.push(newTitle)

        // fade all others
        removeTitle(newTitle)
      }

      const removeTitle = (title = null) => {
        // iterate through all, except object and fade/remove all
        for (let i = 0; i < activeTitles.length; i += 1) {
          if (activeTitles[i] !== title) {
            const ele = activeTitles[i]

            const tl = gsap.timeline({
              onComplete: () => {
                activeTitles[i][1].removeEventListener(
                  "click",
                  navRouterTitle,
                  false
                )
                activeTitles[i][1].removeEventListener(
                  "touchstart",
                  navRouterTitle,
                  false
                )
                activeTitles[i][1].remove()

                const index = activeTitles.indexOf(ele)
                activeTitles.slice(index, 1)
              },
            })

            tl.to(ele[1], 0.4, { autoAlpha: 0 })
          }
        }
      }

      // GLOW

      // Globe
      const earthGlowMat = new THREE.SpriteMaterial({ map: spriteMapBlue })
      earthGlowMat.transparent = true

      const glowX = 4.5
      const glowY = 4.5

      const earthGlow = new THREE.Sprite(earthGlowMat)
      earthGlow.scale.set(glowX, glowY, 1)
      earthGlow.position.set(0, 0, 0)
      pivotGlobe.add(earthGlow)

      // Mood

      const moodGlow = new THREE.Sprite(earthGlowMat)
      moodGlow.scale.set(glowX, glowY, 1)
      moodGlow.position.set(0, 0, 0)
      pivotMood.add(moodGlow)

      // RENDER FUNCTIONS

      const updateTitlePositions = () => {
        // adds tracking animation to titles
        if (activeTitles.length > 0) {
          setActiveTitles()
        }
      }

      const updateTitleRaycast = () => {
        if (currentTarget && this.isMobile) {
          raycasterTitle.setFromCamera(posRaycast, camera)

          intersectsTitle =
            this.currentNav === pivotGlobe
              ? raycasterTitle.intersectObjects(spriteCities)
              : raycasterTitle.intersectObjects(spriteMoodsFlat)

          if (intersectsTitle.length > 0) {
            if (
              intersectsTitle[0].object.name === "globe" ||
              intersectsTitle[0].object.name === "mood"
            ) {
              setTarget(null)
              removeTitle()
              removeSprites()
            }
          }
        }
      }

      const updateGlobeControls = () => {
        if (this.currentNav === pivotGlobe && isThrowing) {
          // HORIZONAL ROTATION
          deltaX =
            (targetRotationXGlobe - pivotGlobe.rotation.y) * rotationInertia
          pivotGlobe.rotation.y += deltaX

          // VERTICAL ROTATION
          deltaY =
            (targetRotationYGlobe - pivotGlobe.rotation.x) * rotationInertia
          if (isThrowing && checkMaxAngle(pivotGlobe, deltaY, "x")) {
            pivotGlobe.rotation.x += deltaY
          }
        }
      }

      const updateMoodControls = () => {
        if (this.currentNav === pivotMood && isThrowing) {
          // HORIZONAL ROTATION
          deltaX =
            (targetRotationXMood - pivotMood.rotation.y) * rotationInertia
          pivotMood.rotation.y += deltaX

          // VERTICAL ROTATION
          deltaY =
            (targetRotationYMood - pivotMood.rotation.x) * rotationInertia
          if (isThrowing && checkMaxAngle(pivotMood, deltaY, "x")) {
            pivotMood.rotation.x += deltaY
          }
        }
      }

      const updateCameraZoomIn = () => {
        if (!this.isMobile && isDragging && !currentTarget) {
          if (camera.position.z >= maxZoom) {
            zoomPosition *= zoomInSpeed
            camera.position.z -= zoomPosition
          }
        }

        if (isDragging && this.isMobile) {
          if (camera.position.z >= maxZoom) {
            zoomPosition *= zoomInSpeed
            camera.position.z -= zoomPosition
          }
        }
      }

      const updateCameraZoomOut = () => {
        if (!isDragging && lerpTimerBool) {
          if (camera.position.z <= minZoom) {
            camera.position.z += zoomOutSpeed
          }

          // if momentum is below certain amount, we are not throwing
          if (Math.abs(deltaX) < 0.005 && Math.abs(deltaY) < 0.005) {
            isThrowing = false
          }
        }
      }

      const updateGlobeRotation = () => {
        if (this.currentNav === pivotGlobe) {
          if (!isDragging && lerpTimerBool) {
            if (!isThrowing) {
              targetRotationYGlobe = pivotGlobe.rotation.x

              if (pivotGlobe.rotation.x > 0.01) {
                pivotGlobe.rotation.x += -0.0015
              } else if (pivotGlobe.rotation.x < -0.01) {
                pivotGlobe.rotation.x += 0.0015
              }
            }
            globe.rotateOnAxis(globeAxis, 0.0015)
          }

          targetRotationYMood = pivotMood.rotation.x

          if (pivotMood.rotation.x > 0.01) {
            pivotMood.rotation.x += -0.0015
          } else if (pivotMood.rotation.x < -0.01) {
            pivotMood.rotation.x += 0.0015
          }
          mood.rotateOnAxis(globeAxis, 0.0015)
        }
      }

      const updateMoodRotation = () => {
        if (this.currentNav === pivotMood) {
          if (!isDragging && lerpTimerBool) {
            if (!isThrowing) {
              targetRotationYMood = pivotMood.rotation.x
              if (pivotMood.rotation.x > 0.01) {
                pivotMood.rotation.x += -0.0015
              } else if (pivotMood.rotation.x < -0.01) {
                pivotMood.rotation.x += 0.0015
              }
            }
            mood.rotateOnAxis(globeAxis, 0.0015)
          }

          targetRotationYGlobe = pivotGlobe.rotation.x

          if (pivotGlobe.rotation.x > 0.01) {
            pivotGlobe.rotation.x += -0.0015
          } else if (pivotGlobe.rotation.x < -0.01) {
            pivotGlobe.rotation.x += 0.0015
          }
          globe.rotateOnAxis(globeAxis, 0.0015)
        }
      }

      const render = (time) => {
        if (
          !this.$store.state.transitions.isPlay &&
          !this.$store.state.transitions.isResize
        )
          return

        if (resizeRendererToDisplaySize(renderer)) {
          camera.aspect = canvas.clientWidth / canvas.clientHeight
          camera.updateProjectionMatrix()
        }

        if (pivotMain && mood && globe) {
          if (!this.isIndex && textureLoaded) {
            pauseAnimation(400)
            addResizeListener()
          }

          if (this.isIndex) {
            updateTitlePositions()
            updateTitleRaycast()
            updateGlobeControls()
            updateMoodControls()
            updateCameraZoomIn()
            updateCameraZoomOut()
            updateGlobeRotation()
            updateMoodRotation()
          }
        }

        renderer.render(scene, camera)

        requestAnimationFrame(render)
      }

      playAnimation()

      // RENDER ON RESIZE

      const resizeTimerFn = () => {
        this.$store.commit("transitions/clearResizeTimer")
        this.$store.commit("transitions/setIsResize", false)
        this.$store.state.transitions.pause(0)
      }

      const resizingRender = () => {
        if (!this.$store.state.transitions.isResize) {
          this.$store.commit("transitions/setIsResize", true)
          requestAnimationFrame(render)
        }

        this.$store.commit("transitions/clearResizeTimer")
        this.$store.commit(
          "transitions/setResizeTimer",
          setInterval(resizeTimerFn, 2200)
        )
      }

      const addResizeListener = () => {
        window.addEventListener("resize", resizingRender, false)
      }

      const removeResizeListener = () => {
        window.removeEventListener("resize", resizingRender, false)
      }

      this.$store.commit("transitions/setAddResize", addResizeListener)
      this.$store.commit("transitions/setRemoveResize", removeResizeListener)

      renderer
        .getContext()
        .canvas.addEventListener("webglcontextlost", pauseAnimation, false)
    },
  },
}
</script>

<style lang="scss" scoped>
.nav3d {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 100vh;
}

.navContainer {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  transform-origin: bottom right;
  z-index: $z-above;
  cursor: grab;
}

.welcome {
  display: none;
}

.sceneContainer {
  pointer-events: none;
  text-align: center;

  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 250%;
}

.scene {
  width: 100%;
  min-height: 100vh;
  height: 152vw;
  display: block;
  pointer-events: none;
  transition: height 2s;
}

.toggleContainer {
  position: absolute;
  bottom: 5rem;
  left: 50%;
  transform: translate(-50%, 0);
  z-index: $z-modal;
}

.navFeedContainer {
  display: none;
}

.navContainerMobile {
  position: fixed;
  top: 10vh;
  bottom: 10vh;
}

.sceneMobile {
  height: 110vh !important;
}

.toggleContainerMobile {
  top: 10vh !important;
  bottom: auto !important;
}

.navFeedContainerMobile {
  top: 75vh;
  position: absolute;
  left: 50%;
  transform: translate(-50%, 0);
  z-index: $z-modal;
  width: 17rem;
  display: flex;
  justify-content: center;
}

@media (min-width: $bp-mobile) {
  .toggleContainer {
    position: absolute;
    bottom: 3rem;
  }
}

@media (min-width: $bp-tablet) {
  .scene {
    width: 100%;
    height: 135vh;
    display: block;
    pointer-events: none;
  }
}

@media (min-width: $bp-desktop) {
  .scene {
    width: 100%;
    height: 160vh;
    display: block;
    pointer-events: none;
  }

  .toggleContainer {
    position: absolute;
    top: 50%;
    bottom: auto;
    left: 1rem;
    transform: translate(0, -50%);
  }

  .toggleContainer {
    left: 2rem;
  }
}
</style>
